// Code generated by mockery v2.36.0. DO NOT EDIT.

package mocks

import (
	mock "github.com/stretchr/testify/mock"

	serialization "github.com/microsoft/kiota-abstractions-go/serialization"

	store "github.com/microsoft/kiota-abstractions-go/store"

	time "time"

	uuid "github.com/google/uuid"
)

// PasswordCredentialable is an autogenerated mock type for the PasswordCredentialable type
type PasswordCredentialable struct {
	mock.Mock
}

// GetAdditionalData provides a mock function with given fields:
func (_m *PasswordCredentialable) GetAdditionalData() map[string]interface{} {
	ret := _m.Called()

	var r0 map[string]interface{}
	if rf, ok := ret.Get(0).(func() map[string]interface{}); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]interface{})
		}
	}

	return r0
}

// GetBackingStore provides a mock function with given fields:
func (_m *PasswordCredentialable) GetBackingStore() store.BackingStore {
	ret := _m.Called()

	var r0 store.BackingStore
	if rf, ok := ret.Get(0).(func() store.BackingStore); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(store.BackingStore)
		}
	}

	return r0
}

// GetCustomKeyIdentifier provides a mock function with given fields:
func (_m *PasswordCredentialable) GetCustomKeyIdentifier() []byte {
	ret := _m.Called()

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	return r0
}

// GetDisplayName provides a mock function with given fields:
func (_m *PasswordCredentialable) GetDisplayName() *string {
	ret := _m.Called()

	var r0 *string
	if rf, ok := ret.Get(0).(func() *string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*string)
		}
	}

	return r0
}

// GetEndDateTime provides a mock function with given fields:
func (_m *PasswordCredentialable) GetEndDateTime() *time.Time {
	ret := _m.Called()

	var r0 *time.Time
	if rf, ok := ret.Get(0).(func() *time.Time); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*time.Time)
		}
	}

	return r0
}

// GetFieldDeserializers provides a mock function with given fields:
func (_m *PasswordCredentialable) GetFieldDeserializers() map[string]func(serialization.ParseNode) error {
	ret := _m.Called()

	var r0 map[string]func(serialization.ParseNode) error
	if rf, ok := ret.Get(0).(func() map[string]func(serialization.ParseNode) error); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]func(serialization.ParseNode) error)
		}
	}

	return r0
}

// GetHint provides a mock function with given fields:
func (_m *PasswordCredentialable) GetHint() *string {
	ret := _m.Called()

	var r0 *string
	if rf, ok := ret.Get(0).(func() *string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*string)
		}
	}

	return r0
}

// GetKeyId provides a mock function with given fields:
func (_m *PasswordCredentialable) GetKeyId() *uuid.UUID {
	ret := _m.Called()

	var r0 *uuid.UUID
	if rf, ok := ret.Get(0).(func() *uuid.UUID); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*uuid.UUID)
		}
	}

	return r0
}

// GetOdataType provides a mock function with given fields:
func (_m *PasswordCredentialable) GetOdataType() *string {
	ret := _m.Called()

	var r0 *string
	if rf, ok := ret.Get(0).(func() *string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*string)
		}
	}

	return r0
}

// GetSecretText provides a mock function with given fields:
func (_m *PasswordCredentialable) GetSecretText() *string {
	ret := _m.Called()

	var r0 *string
	if rf, ok := ret.Get(0).(func() *string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*string)
		}
	}

	return r0
}

// GetStartDateTime provides a mock function with given fields:
func (_m *PasswordCredentialable) GetStartDateTime() *time.Time {
	ret := _m.Called()

	var r0 *time.Time
	if rf, ok := ret.Get(0).(func() *time.Time); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*time.Time)
		}
	}

	return r0
}

// Serialize provides a mock function with given fields: writer
func (_m *PasswordCredentialable) Serialize(writer serialization.SerializationWriter) error {
	ret := _m.Called(writer)

	var r0 error
	if rf, ok := ret.Get(0).(func(serialization.SerializationWriter) error); ok {
		r0 = rf(writer)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetAdditionalData provides a mock function with given fields: value
func (_m *PasswordCredentialable) SetAdditionalData(value map[string]interface{}) {
	_m.Called(value)
}

// SetBackingStore provides a mock function with given fields: value
func (_m *PasswordCredentialable) SetBackingStore(value store.BackingStore) {
	_m.Called(value)
}

// SetCustomKeyIdentifier provides a mock function with given fields: value
func (_m *PasswordCredentialable) SetCustomKeyIdentifier(value []byte) {
	_m.Called(value)
}

// SetDisplayName provides a mock function with given fields: value
func (_m *PasswordCredentialable) SetDisplayName(value *string) {
	_m.Called(value)
}

// SetEndDateTime provides a mock function with given fields: value
func (_m *PasswordCredentialable) SetEndDateTime(value *time.Time) {
	_m.Called(value)
}

// SetHint provides a mock function with given fields: value
func (_m *PasswordCredentialable) SetHint(value *string) {
	_m.Called(value)
}

// SetKeyId provides a mock function with given fields: value
func (_m *PasswordCredentialable) SetKeyId(value *uuid.UUID) {
	_m.Called(value)
}

// SetOdataType provides a mock function with given fields: value
func (_m *PasswordCredentialable) SetOdataType(value *string) {
	_m.Called(value)
}

// SetSecretText provides a mock function with given fields: value
func (_m *PasswordCredentialable) SetSecretText(value *string) {
	_m.Called(value)
}

// SetStartDateTime provides a mock function with given fields: value
func (_m *PasswordCredentialable) SetStartDateTime(value *time.Time) {
	_m.Called(value)
}

// NewPasswordCredentialable creates a new instance of PasswordCredentialable. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPasswordCredentialable(t interface {
	mock.TestingT
	Cleanup(func())
}) *PasswordCredentialable {
	mock := &PasswordCredentialable{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
